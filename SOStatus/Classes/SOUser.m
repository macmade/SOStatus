/*******************************************************************************
 * Copyright (c) 2011, Jean-David Gadina <macmade@eosgarden.com>
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
 
/* $Id$ */

/*!
 * @file        ...
 * @copyright   eosgarden 2011 - Jean-David Gadina <macmade@eosgarden.com>
 * @abstract    ...
 */

#import "SOUser.h"
#import "SOAnswer.h"
#import "SOQuestion.h"
#import "SOComment.h"
#import "SOFavorite.h"
#import "SOMention.h"
#import "SOReputation.h"
#import "SOTimeline.h"
#import "NetworkReachability.h"

@interface SOUser( Private )

- ( id )jsonQuery: ( NSString * )part;

@end

@implementation SOUser( Private )

- ( id )jsonQuery: ( NSString * )part
{
    NetworkReachability * reachability;
    NSURL               * url;
    NSURLResponse       * response;
    NSURLRequest        * request;
    NSData              * data;
    NSError             * error;
    id                    json;
    
    reachability = [ NetworkReachability networkReachabilityWithHostName: [ [ NSURL URLWithString: SO_URL_API ] host ] ];
    
    if( reachability.currentReachabilityStatus == NetworkStatusNotReachable  )
    {
        return nil;
    }
    
    url        = [ NSURL URLWithString: [ NSString stringWithFormat: @"%@%@?key=%@", SO_URL_API, [ NSString stringWithFormat: part, [ NSString stringWithFormat: @"%lu", ( unsigned long )_itemID ] ], SO_API_KEY ] ];
    response   = nil;
    error      = nil;
    request    = [ NSURLRequest requestWithURL: url ];
    data       = [ NSURLConnection sendSynchronousRequest: request returningResponse: &response error: &error ];
    
    if( error != nil || data == nil )
    {
        return nil;
    }
    
    json = [ NSJSONSerialization JSONObjectWithData: data options: NSJSONReadingMutableContainers error: NULL ];
    
    return json;
}

@end

@implementation SOUser

@synthesize username        = _username;
@synthesize totalReputation = _totalReputation;
@synthesize goldBadges      = _goldBadges;
@synthesize silverBadges    = _silverBadges;
@synthesize bronzeBadges    = _bronzeBadges;
@synthesize answers         = _answers;
@synthesize comments        = _comments;
@synthesize favorites       = _favorites;
@synthesize mentions        = _mentions;
@synthesize questions       = _questions;
@synthesize reputation      = _reputation;
@synthesize timeline        = _timeline;
@synthesize questionCount   = _questionCount;
@synthesize answerCount     = _answerCount;
@synthesize viewCount       = _viewCount;
@synthesize upVoteCount     = _upVoteCount;
@synthesize downVoteCount   = _downVoteCount;
@synthesize acceptRate      = _acceptRate;

- ( id )initWithUserID: ( NSUInteger )userID
{
    if( ( self = [ self init ] ) )
    {
        _itemID = userID;
        
        if( [ self refresh ] == NO )
        {
            [ self release ];
            
            return nil;
        }
    }
    
    return self;
}

- ( void )dealloc
{
    [ _username     release ];
    [ _answers      release ];
    [ _questions    release ];
    [ _comments     release ];
    [ _favorites    release ];
    [ _mentions     release ];
    [ _reputation   release ];
    [ _timeline     release ];
    
    [ super dealloc ];
}

- ( BOOL )refresh
{
    NSDictionary * json;
    NSDictionary * user;
    NSDictionary * badges;
    NSDictionary * questions;
    NSDictionary * answers;
    NSDictionary * comments;
    NSDictionary * favorites;
    NSDictionary * mentions;
    NSDictionary * reputation;
    NSDictionary * timeline;
    
    @synchronized( self )
    {
        json = [ self jsonQuery: SO_URL_API_USERS ];
        
        if( json == nil )
        {
            return NO;
        }
        
        if( [ [ json objectForKey: @"users" ] count ] != 1 )
        {
            return NO;
        }
        
        user             = [ [ json objectForKey: @"users" ] objectAtIndex: 0 ];
        _username        = [ [ user objectForKey: @"display_name" ] copy ];
        _totalReputation = [ [ user objectForKey: @"reputation" ] integerValue ];
        badges           = [ user objectForKey: @"badge_counts" ];
        
        if( badges != nil && [ badges count ] != 0 )
        {
            _goldBadges   = [ [ badges objectForKey: @"gold" ]      unsignedIntegerValue ];
            _silverBadges = [ [ badges objectForKey: @"silver" ]    unsignedIntegerValue ];
            _bronzeBadges = [ [ badges objectForKey: @"bronze" ]    unsignedIntegerValue ];
        }
        
        _questionCount  = [ [ user objectForKey: @"question_count" ]  unsignedIntegerValue ];
        _answerCount    = [ [ user objectForKey: @"answer_count" ]    unsignedIntegerValue ];
        _viewCount      = [ [ user objectForKey: @"view_count" ]      unsignedIntegerValue ];
        _upVoteCount    = [ [ user objectForKey: @"up_vote_count" ]   unsignedIntegerValue ];
        _downVoteCount  = [ [ user objectForKey: @"down_vote_count" ] unsignedIntegerValue ];
        _acceptRate     = [ [ user objectForKey: @"accept_rate" ]     unsignedIntegerValue ];
        
        questions   = [ self jsonQuery: SO_URL_API_USERS_QUESTIONS ];
        answers     = [ self jsonQuery: SO_URL_API_USERS_ANSWERS ];
        comments    = [ self jsonQuery: SO_URL_API_USERS_COMMENTS ];
        favorites   = [ self jsonQuery: SO_URL_API_USERS_FAVORITES ];
        mentions    = [ self jsonQuery: SO_URL_API_USERS_MENTIONS ];
        reputation  = [ self jsonQuery: SO_URL_API_USERS_REPUTATION ];
        timeline    = [ self jsonQuery: SO_URL_API_USERS_TIMELINE ];
        
        if( questions != nil )
        {
            [ _questions release ];
            
            _questions = [ [ SOQuestion questionsFromJSONDictionary: questions ] retain ];
        }
        
        if( answers != nil )
        {
            [ _answers release ];
            
            _answers = [ [ SOAnswer answersFromJSONDictionary: answers ] retain ];
        }
        
        if( comments != nil )
        {
            [ _comments release ];
            
            _comments = [ [ SOComment commentsFromJSONDictionary: comments ] retain ];
        }
        
        if( favorites != nil )
        {
            [ _favorites release ];
            
            _favorites = [ [ SOFavorite favoritesFromJSONDictionary: favorites ] retain ];
        }
        
        if( mentions != nil )
        {
            [ _mentions release ];
            
            _mentions = [ [ SOMention mentionsFromJSONDictionary: mentions ] retain ];
        }
        
        if( reputation != nil )
        {
            [ _reputation release ];
            
            _reputation = [ [ SOReputation reputationsFromJSONDictionary: reputation ] retain ];
        }
        
        if( timeline != nil )
        {
            [ _timeline release ];
            
            _timeline = [ [ SOTimeline timelinesFromJSONDictionary: timeline ] retain ];
        }
        
        return YES;
    }
}

- ( NSString * )reputationString
{
    if( _totalReputation < 10000 )
    {
        return [ NSString stringWithFormat: @"%lu", _totalReputation ];
    }
    
    return [ NSString stringWithFormat: @"%.1fK", ( double )( ( double )_totalReputation / ( double )1000 ) ];
}

@end
